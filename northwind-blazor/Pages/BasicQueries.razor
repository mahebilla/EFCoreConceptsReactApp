@*
    BASIC QUERIES PAGE — Blazor Concept: @page Routing Directive

    React equivalent: BasicQueries.tsx with <Route path="/basic-queries">
    Angular equivalent: basic-queries.component.ts with { path: 'basic-queries', loadComponent }

    Key Blazor concepts:
    1. @page "/basic-queries" — Declares this component as a routable page
       The Router in App.razor automatically discovers all @page directives.
       React:  <Route path="/basic-queries" element={<BasicQueries />} />
       Angular: { path: 'basic-queries', loadComponent: () => import(...) }

       Unlike React/Angular where routes are defined in a central file,
       Blazor routes are declared directly on the component — decentralized routing.

    2. The demos list uses C# List<EndpointDemo> — equivalent to TypeScript's EndpointDemo[]
       C# uses "new()" to create instances; JS uses object literals {}.
*@
@page "/basic-queries"

<DemoSection
    Title="Basic LINQ Queries"
    Subtitle="Demonstrates LINQ method syntax, query syntax, Find, FirstOrDefault, aggregates, and more."
    Demos="demos" />

@code {
    // List<EndpointDemo> — C# typed list (like TypeScript's EndpointDemo[])
    // Each demo defines the API call configuration for the DemoSection component
    private List<EndpointDemo> demos = new()
    {
        new("Where (LINQ Filter)", "/api/basicqueries/where", "GET",
            @"// GET /api/basicqueries/where
var products = await _context.Products
    .Where(p => p.UnitPrice > 20)
    .Select(p => new {
        p.ProductId,
        p.ProductName,
        p.UnitPrice,
        p.UnitsInStock
    })
    .ToListAsync();",
            "Filter products with UnitPrice > 20 using Where()"),

        new("Find (Primary Key)", "/api/basicqueries/find/1", "GET",
            @"// GET /api/basicqueries/find/{id}
var product = await _context.Products.FindAsync(id);

// FindAsync checks the local cache first,
// only hitting the database if needed.",
            "Look up product by primary key using FindAsync()"),

        new("FirstOrDefault", "/api/basicqueries/firstordefault", "GET",
            @"// GET /api/basicqueries/firstordefault
var product = await _context.Products
    .Where(p => p.CategoryId == 1)
    .FirstOrDefaultAsync();

// Returns null if no match is found.",
            "Get first product in category 1"),

        new("SingleOrDefault", "/api/basicqueries/singleordefault/1", "GET",
            @"// GET /api/basicqueries/singleordefault/{id}
var product = await _context.Products
    .Where(p => p.ProductId == id)
    .SingleOrDefaultAsync();

// Throws InvalidOperationException if more than one element.",
            "Expects exactly one result — throws if more than one"),

        new("Any (Existence Check)", "/api/basicqueries/any", "GET",
            @"// GET /api/basicqueries/any
var anyExpensive = await _context.Products
    .AnyAsync(p => p.UnitPrice > 100);

return Ok(new { anyExpensive });",
            "Check if any product costs > $100"),

        new("Count", "/api/basicqueries/count", "GET",
            @"// GET /api/basicqueries/count
var totalCount = await _context.Products.CountAsync();
var discontinuedCount = await _context.Products
    .CountAsync(p => p.Discontinued);

return Ok(new { totalCount, discontinuedCount });",
            "Count total and discontinued products"),

        new("Aggregates (Avg, Max, Min, Sum)", "/api/basicqueries/aggregates", "GET",
            @"// GET /api/basicqueries/aggregates
var avgPrice = await _context.Products
    .AverageAsync(p => (double?)p.UnitPrice ?? 0);
var maxPrice = await _context.Products
    .MaxAsync(p => (double?)p.UnitPrice ?? 0);
var minPrice = await _context.Products
    .MinAsync(p => (double?)p.UnitPrice ?? 0);
var totalValue = await _context.Products
    .SumAsync(p => (double?)(p.UnitPrice * p.UnitsInStock) ?? 0);

return Ok(new { avgPrice, maxPrice, minPrice, totalValue });",
            "Aggregate functions on Products table"),

        new("OrderBy / ThenBy", "/api/basicqueries/orderby", "GET",
            @"// GET /api/basicqueries/orderby
var products = await _context.Products
    .OrderByDescending(p => p.UnitPrice)
    .ThenBy(p => p.ProductName)
    .Take(10)
    .Select(p => new {
        p.ProductName,
        p.UnitPrice,
        p.CategoryId
    })
    .ToListAsync();",
            "Top 10 most expensive products sorted"),

        new("GroupBy", "/api/basicqueries/groupby", "GET",
            @"// GET /api/basicqueries/groupby
var groups = await _context.Products
    .GroupBy(p => p.CategoryId)
    .Select(g => new {
        CategoryId = g.Key,
        ProductCount = g.Count(),
        AvgPrice = g.Average(p => p.UnitPrice),
        MaxPrice = g.Max(p => p.UnitPrice)
    })
    .ToListAsync();",
            "Group products by category"),

        new("Select Projection", "/api/basicqueries/select", "GET",
            @"// GET /api/basicqueries/select
var products = await _context.Products
    .Select(p => new {
        p.ProductName,
        p.UnitPrice,
        p.UnitsInStock,
        StockValue = p.UnitPrice * p.UnitsInStock,
        IsExpensive = p.UnitPrice > 50
    })
    .Take(10)
    .ToListAsync();",
            "Project products with computed properties"),

        new("Distinct", "/api/basicqueries/distinct", "GET",
            @"// GET /api/basicqueries/distinct
var cities = await _context.Customers
    .Select(c => c.City)
    .Where(c => c != null)
    .Distinct()
    .OrderBy(c => c)
    .ToListAsync();",
            "Get distinct customer cities"),

        new("Contains (SQL IN)", "/api/basicqueries/contains", "GET",
            @"// GET /api/basicqueries/contains
var categoryIds = new List<int> { 1, 2, 3 };

var products = await _context.Products
    .Where(p => categoryIds.Contains(p.CategoryId ?? 0))
    .Select(p => new {
        p.ProductName,
        p.CategoryId,
        p.UnitPrice
    })
    .ToListAsync();

// Translates to: WHERE CategoryID IN (1, 2, 3)",
            "Products in categories 1, 2, or 3 using Contains()"),

        new("All", "/api/basicqueries/all", "GET",
            @"// GET /api/basicqueries/all
var allInStock = await _context.Products
    .AllAsync(p => p.UnitsInStock > 0);

return Ok(new { allInStock });",
            "Check if ALL products are in stock"),

        new("LINQ Query Syntax", "/api/basicqueries/querysyntax", "GET",
            @"// GET /api/basicqueries/querysyntax
var products = await (
    from p in _context.Products
    where p.UnitPrice > 20
    orderby p.ProductName
    select new {
        p.ProductName,
        p.UnitPrice,
        p.CategoryId
    }
).Take(10).ToListAsync();",
            "Using from/where/select keywords instead of method chain"),

        new("Join", "/api/basicqueries/join", "GET",
            @"// GET /api/basicqueries/join
var results = await _context.Products
    .Join(
        _context.Categories,
        p => p.CategoryId,
        c => c.CategoryId,
        (p, c) => new {
            p.ProductName,
            p.UnitPrice,
            CategoryName = c.CategoryName
        }
    )
    .Take(10)
    .ToListAsync();",
            "Explicit LINQ join between Products and Categories"),

        new("TagWith", "/api/basicqueries/tagwith", "GET",
            @"// GET /api/basicqueries/tagwith
var products = await _context.Products
    .TagWith(""Getting top 5 expensive products for dashboard"")
    .OrderByDescending(p => p.UnitPrice)
    .Take(5)
    .ToListAsync();

// Generated SQL includes:
// -- Getting top 5 expensive products for dashboard",
            "Adds SQL comment for diagnostics"),
    };
}
